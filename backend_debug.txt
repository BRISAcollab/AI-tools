import os
import uuid
import json
import threading
import time
import io
from typing import Dict, Any, List

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse, JSONResponse, Response
from fastapi.staticfiles import StaticFiles
from dotenv import load_dotenv
from pydantic import BaseModel, Field
import requests


load_dotenv()

app = FastAPI(title="Triage Backend", version="0.1.0")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


class StartPayload(BaseModel):
    model: str = Field(default="gpt-5")
    study_synopsis: str
    inclusion_criteria: List[str] = []
    exclusion_criteria: List[str] = []
    filename: str = ""
    sheet: str = ""
    records: List[Dict[str, Any]]


JOBS: Dict[str, Dict[str, Any]] = {}


def build_prompt(synopsis: str, inc: List[str], exc: List[str], title: str, abstract: str) -> str:
    inc_lines = "\n".join(f"- {i}" for i in inc) if inc else "- (none provided)"
    exc_lines = "\n".join(f"- {e}" for e in exc) if exc else "- (none provided)"
    return (
        "You are a researcher rigorously screening titles and abstracts of scientific papers.\n"
        "Use ONLY the PICO/description and the criteria below to decide include, exclude, or maybe.\n"
        "Return STRICT JSON with keys: decision (include|exclude|maybe) and rationale (<=12 words).\n\n"
        f"Study description/PICO: {synopsis.strip()}\n\n"
        f"Inclusion criteria (all must be met):\n{inc_lines}\n\n"
        f"Exclusion criteria (any triggers exclusion):\n{exc_lines}\n\n"
        "Rules:\n"
        "- If any exclusion criterion is met OR not all inclusion criteria are met => exclude.\n"
        "- If all inclusion criteria are met => include.\n"
        "- If insufficient information => maybe.\n\n"
        f"Now screen this record:\nTitle: {title or ''}\nAbstract: {abstract or ''}\n\n"
        'Respond with JSON only: {"decision":"include|exclude|maybe","rationale":"<=12 words"}'
    )


def call_openai_chat(model: str, prompt: str, api_key: str) -> Dict[str, Any]:
    url = "https://api.openai.com/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json",
    }
    body = {
        "model": model,
        "temperature": 0,
        "messages": [
            {"role": "system", "content": "You return only strict JSON and nothing else."},
            {"role": "user", "content": prompt},
        ],
    }
    r = requests.post(url, headers=headers, json=body, timeout=60)
    if r.status_code != 200:
        raise RuntimeError(f"OpenAI error {r.status_code}: {r.text[:200]}")
    data = r.json()
    try:
        content = data["choices"][0]["message"]["content"].strip()
    except Exception:
        raise RuntimeError("Invalid OpenAI response structure")
    # Strip code fences if present
    if content.startswith("```"):
        content = content.strip("`")
        if "\n" in content:
            content = content.split("\n", 1)[1].strip()
    try:
        parsed = json.loads(content)
    except Exception:
        lower = content.lower()
        decision = "maybe"
        if "include" in lower and "exclude" not in lower:
            decision = "include"
        elif "exclude" in lower and "include" not in lower:
            decision = "exclude"
        rationale = content.split("\n")[0][:80]
        return {"decision": decision, "rationale": rationale}
    decision = str(parsed.get("decision", "")).strip().lower()
    rationale = str(parsed.get("rationale", "")).strip()
    if decision not in {"include", "exclude", "maybe"}:
        decision = "maybe"
    if len(rationale.split()) > 12:
        rationale = " ".join(rationale.split()[:12])
    if not rationale:
        rationale = "insufficient information"
    return {"decision": decision, "rationale": rationale}


def worker(job_id: str):
    job = JOBS[job_id]
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        job["status"] = "error"
        job["error"] = "OPENAI_API_KEY not set"
        return
    records = job["records"]
    total = len(records)
    job["total"] = total
    job["processed"] = 0
    results = []
    model = job["model"]
    synopsis = job["study_synopsis"]
    inc = job["inclusion_criteria"]
    exc = job["exclusion_criteria"]

    for idx, rec in enumerate(records, start=1):
        if job.get("status") == "cancelled":
            break
        title = rec.get("title") or ""
        abstract = rec.get("abstract") or ""
        rid = rec.get("id", idx)
        try:
            prompt = build_prompt(synopsis, inc, exc, title, abstract)
            out = call_openai_chat(model, prompt, api_key)
        except Exception as e:
            out = {"decision": "maybe", "rationale": f"error: {str(e)[:70]}"}
        results.append({
            "id": rid,
            "title": title,
            "abstract": abstract,
            "screening_decision": out["decision"],
            "screening_reason": out["rationale"],
        })
        job["processed"] = idx
        job["results"] = results
        # small pacing to avoid hammering
        time.sleep(0.05)

    job["status"] = "done"


@app.post("/api/start")
def start_job(payload: StartPayload):
    if not payload.records:
        raise HTTPException(status_code=400, detail="records vazio")
    job_id = str(uuid.uuid4())
    JOBS[job_id] = {
        "status": "running",
        "model": payload.model or "gpt-5",
        "study_synopsis": payload.study_synopsis or "",
        "inclusion_criteria": payload.inclusion_criteria or [],
        "exclusion_criteria": payload.exclusion_criteria or [],
        "filename": payload.filename,
        "sheet": payload.sheet,
        "records": payload.records,
        "processed": 0,
        "total": len(payload.records),
        "results": [],
    }
    th = threading.Thread(target=worker, args=(job_id,), daemon=True)
    th.start()
    return {"job_id": job_id}


@app.get("/status/{job_id}")
def status(job_id: str):
    job = JOBS.get(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="job nÃ£o encontrado")
    return {
        "status": job.get("status"),
        "processed": job.get("processed", 0),
        "total": job.get("total", 0),
        "filename": job.get("filename"),
    }


@app.get("/progress/{job_id}")
def progress(job_id: str):
    job = JOBS.get(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="job nÃ£o encontrado")

    def event_stream():
        last = -1
        while True:
            j = JOBS.get(job_id)
            if not j:
                yield f"data: {json.dumps({'status': 'error', 'detail': 'job missing'})}\n\n"
                break
            processed = j.get("processed", 0)
            total = j.get("total", 0)
            status = j.get("status")
            if processed != last or status != "running":
                payload = {"status": status, "processed": processed, "total": total}
                yield f"data: {json.dumps(payload)}\n\n"
                last = processed
            if status in {"done", "error", "cancelled"}:
                break
            time.sleep(0.5)

    return StreamingResponse(event_stream(), media_type="text/event-stream")


@app.get("/result/{job_id}")
def result(job_id: str, format: str = "csv"):
    job = JOBS.get(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="job nÃ£o encontrado")
    if job.get("status") != "done":
        raise HTTPException(status_code=400, detail="job nÃ£o finalizado")
    rows = job.get("results", [])
    if not rows:
        return JSONResponse({"rows": []})
    # Build CSV in memory
    import csv
    output = io.StringIO()
    fieldnames = [
        "id",
        "title",
        "abstract",
        "screening_decision",
        "screening_reason",
    ]
    writer = csv.DictWriter(output, fieldnames=fieldnames)
    writer.writeheader()
    for r in rows:
        writer.writerow({k: r.get(k, "") for k in fieldnames})
    data = output.getvalue().encode("utf-8")
    return Response(
        content=data,
        media_type="text/csv; charset=utf-8",
        headers={
            "Content-Disposition": f"attachment; filename=triage_{job_id}.csv"
        },
    )


# Run with: uvicorn backend:app --reload --port 8000

